2023-09-01 22:02:18:200 grammar LogManager.java:25 before: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE POINT (BLOCK (ALT '.'))) (RULE COMA (BLOCK (ALT ','))) (RULE PTCOMA (BLOCK (ALT ';'))) (RULE CORCHETEIZQ (BLOCK (ALT '['))) (RULE CORCHETEDER (BLOCK (ALT ']'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-09-01 22:02:18:242 grammar LogManager.java:25 after: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE SWITCH (BLOCK (ALT 'switch'))) (RULE CASE (BLOCK (ALT 'case'))) (RULE DEFAULT (BLOCK (ALT 'default'))) (RULE GUARD (BLOCK (ALT 'guard'))) (RULE CONTINUE (BLOCK (ALT 'continue'))) (RULE RETURN (BLOCK (ALT 'return'))) (RULE BREAK (BLOCK (ALT 'break'))) (RULE APPEND (BLOCK (ALT 'append'))) (RULE REMOVELAST (BLOCK (ALT 'removeLast'))) (RULE REMOVE (BLOCK (ALT 'remove'))) (RULE AT (BLOCK (ALT 'at'))) (RULE ISEMPTY (BLOCK (ALT 'IsEmpty'))) (RULE COUNT (BLOCK (ALT 'count'))) (RULE FUNC (BLOCK (ALT 'func'))) (RULE INOUT (BLOCK (ALT 'inout'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE POINT (BLOCK (ALT '.'))) (RULE COMA (BLOCK (ALT ','))) (RULE PTCOMA (BLOCK (ALT ';'))) (RULE CORCHETEIZQ (BLOCK (ALT '['))) (RULE CORCHETEDER (BLOCK (ALT ']'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-09-01 22:02:19:673 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $expr.e)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE blockelifs (returns []interface{} blkef) (@ init {
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= elif ifstmt)))) {   
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    }))) (RULE ifstmt (returns interfaces.Instruction ift, []interface{} el, interfaces.Instruction else) (BLOCK (ALT IF expr LLAVEIZQ (= ifb block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk}) (ALT IF expr LLAVEIZQ (= ifelseblck block) LLAVEDER ELSE LLAVEIZQ (= elseifblck block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        }) (ALT IF expr LLAVEIZQ (= elif block) LLAVEDER ELSE blockelifs { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); }))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                fmt.Println("entro")}) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($IG.line, $IG.pos,  $ID.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block (= r (BLOCK (ALT CONTINUE) (ALT RETURN) (ALT BREAK))) LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk, $r.text)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParams PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParams.l, $type.t, $block.blk)}) (ALT FUNC ID PARIZQ listParams PARDER LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listaParams.l, environment.NULL, $block.blk)}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ (? (BLOCK (ALT block))) LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk)
    }
}))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB) (ALT PERCENT))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })))))
2023-09-01 22:02:19:690 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $expr.e)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE blockelifs (returns []interface{} blkef) (@ init {
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= elif ifstmt)))) {   
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    }))) (RULE ifstmt (returns interfaces.Instruction ift, []interface{} el, interfaces.Instruction else) (BLOCK (ALT IF expr LLAVEIZQ (= ifb block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk}) (ALT IF expr LLAVEIZQ (= ifelseblck block) LLAVEDER ELSE LLAVEIZQ (= elseifblck block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        }) (ALT IF expr LLAVEIZQ (= elif block) LLAVEDER ELSE blockelifs { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); }))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                fmt.Println("entro")}) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($IG.line, $IG.pos,  $ID.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block (= r (SET CONTINUE RETURN BREAK)) LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk, $r.text)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParams PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParams.l, $type.t, $block.blk)}) (ALT FUNC ID PARIZQ listParams PARDER LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listaParams.l, environment.NULL, $block.blk)}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ (? (BLOCK (ALT block))) LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk)
    }
}))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })))))
2023-09-01 22:02:19:691 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
            
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT whilestmt {$inst = $whilestmt.while}) (ALT forstmt {$inst = $forstmt.for}) (ALT switchstmt {$inst = $switchstmt.switch}) (ALT guardstmt {$inst = $guardstmt.gua}) (ALT transferstmt {$inst = $transferstmt.tran}) (ALT declarevectorstmt {$inst = $declarevectorstmt.decvec}) (ALT appendstmt {$inst = $appendstmt.app}) (ALT removelaststmt {$inst = $removelaststmt.removl}) (ALT removestmt {$inst = $removestmt.remov}) (ALT assignationvecstmt {$inst = $assignationvecstmt.assignvec}) (ALT declarefuncstmt {$inst = $declarefuncstmt.decfunc}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $expr.e)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION (? (BLOCK (ALT PTCOMA))) {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr (? (BLOCK (ALT PTCOMA))) {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE blockelifs (returns []interface{} blkef) (@ init {
$blkef = []interface{}{}
    var listifs []IIfstmtContext
    
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= elif ifstmt)))) {   
        listifs = localctx.(*BlockelifsContext).GetElif()
        for _, a := range listifs {
            $blkef = append($blkef, a.GetIft())
            
        }
    }))) (RULE ifstmt (returns interfaces.Instruction ift, []interface{} el, interfaces.Instruction else) (BLOCK (ALT IF expr LLAVEIZQ (= ifb block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifb.blk, nil); 
                                        $el = $ifb.blk}) (ALT IF expr LLAVEIZQ (= ifelseblck block) LLAVEDER ELSE LLAVEIZQ (= elseifblck block) LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $ifelseblck.blk, $elseifblck.blk); 
                                                                                        $el = $ifelseblck.blk;
                                                                                        
                                                                                        }) (ALT IF expr LLAVEIZQ (= elif block) LLAVEDER ELSE blockelifs { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $elif.blk, $blockelifs.blkef); }))) (RULE switchstmt (returns interfaces.Instruction switch) (BLOCK (ALT SWITCH expr LLAVEIZQ DEFAULT DOUBLEPTS block LLAVEDER { $switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil,  nil, $block.blk);}) (ALT SWITCH expr LLAVEIZQ casestmt LLAVEDER {$switch = instructions.NewSwitch($SWITCH.line, $SWITCH.pos, $expr.e, nil, $casestmt.cas, nil);}))) (RULE casestmt (returns interfaces.Instruction cas) (BLOCK (ALT CASE expr DOUBLEPTS block blockcases { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$block.blk, $blockcases.blkcase)
                                fmt.Println("entro")}) (ALT CASE expr DOUBLEPTS (= sen block) DEFAULT DOUBLEPTS (= def block) { $cas = instructions.NewCase($CASE.line,$CASE.pos, $expr.e,$sen.blk, $def.blk)}))) (RULE blockcases (returns []interface{} blkcase) (@ init {
    $blkcase = []interface{}{}
    var listcases []ICasestmtContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= casedef casestmt)))) {
        listcases = localctx.(*BlockcasesContext).GetCasedef()
        for _, a := range listcases {
            $blkcase = append($blkcase, a.GetCas())
      
        }
    }))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr (? (BLOCK (ALT PTCOMA))) {$assign = instructions.NewAssignation($IG.line, $IG.pos,  $ID.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $expr.e, nil, $block.blk)}) (ALT FOR ID IN (= first expr) POINT POINT (= second expr) LLAVEIZQ block LLAVEDER {$for = instructions.NewFor($FOR.line, $FOR.pos, $ID.text, $first.e, $second.e, $block.blk)}))) (RULE guardstmt (returns interfaces.Instruction gua) (BLOCK (ALT GUARD expr ELSE LLAVEIZQ block (= r (SET CONTINUE RETURN BREAK)) LLAVEDER {$gua = instructions.NewGuard($GUARD.line, $GUARD.pos, $expr.e, $block.blk, $r.text)}))) (RULE transferstmt (returns interfaces.Instruction tran) (BLOCK (ALT RETURN (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, nil)}) (ALT RETURN expr (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewReturnIn($RETURN.line, $RETURN.pos, $expr.e)}) (ALT CONTINUE (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewContinue($CONTINUE.line, $CONTINUE.pos)}) (ALT BREAK (? (BLOCK (ALT PTCOMA))) {$tran = instructions.NewBreak($BREAK.line, $BREAK.pos)}))) (RULE declarevectorstmt (returns interfaces.Instruction decvec) (BLOCK (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ listParams CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, $listParams.l, "")}) (ALT VAR ID DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG CORCHETEIZQ CORCHETEDER (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $ID.text, $type.t, nil, "")}) (ALT VAR ID IG CORCHETEIZQ type CORCHETEDER PARIZQ PARDER (? (BLOCK (ALT PTCOMA)))) (ALT VAR (= F ID) DOUBLEPTS CORCHETEIZQ type CORCHETEDER IG (= S ID) (? (BLOCK (ALT PTCOMA))) {$decvec = instructions.NewToDeclareVector($VAR.line, $VAR.pos, $F.text, $type.t, nil, $S.text)}))) (RULE appendstmt (returns interfaces.Instruction app) (BLOCK (ALT ID POINT APPEND PARIZQ expr PARDER (? (BLOCK (ALT PTCOMA))) {$app = instructions.NewAppend($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE removelaststmt (returns interfaces.Instruction removl) (BLOCK (ALT ID POINT REMOVELAST PARIZQ PARDER (? (BLOCK (ALT PTCOMA))) {$removl = instructions.NewRemoveLast($ID.line, $ID.pos, $ID.text)}))) (RULE removestmt (returns interfaces.Instruction remov) (BLOCK (ALT ID POINT REMOVE PARIZQ AT DOUBLEPTS expr PARDER (? (BLOCK (ALT PTCOMA))) {$remov = instructions.NewRemove($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE emptvecstmt (returns interfaces.Expression emptyvec) (BLOCK (ALT ID POINT ISEMPTY {$emptyvec = expressions.NewEmptyVector($ID.line, $ID.pos, $ID.text)}))) (RULE countvecstmt (returns interfaces.Expression count) (BLOCK (ALT ID POINT COUNT {$count = expressions.NewCount($ID.line, $ID.pos, $ID.text)}))) (RULE accessvecstmt (returns interfaces.Expression accessvec) (BLOCK (ALT ID CORCHETEIZQ expr CORCHETEDER {$accessvec = expressions.NewAccessVector($ID.line, $ID.pos, $ID.text, $expr.e)}))) (RULE assignationvecstmt (returns interfaces.Instruction assignvec) (BLOCK (ALT ID CORCHETEIZQ (= expprim expr) CORCHETEDER IG (= expsegundo expr) (? (BLOCK (ALT PTCOMA))) {$assignvec = instructions.NewAssignationVector($ID.line, $ID.pos, $ID.text, $expprim.e, $expsegundo.e)}))) (RULE declarematrixstmt (returns interfaces.Instruction decmatrix) (BLOCK (ALT VAR ID PARIZQ DOUBLEPTS type PARDER IG (? (BLOCK (ALT PTCOMA)))))) (RULE declarefuncstmt (returns interfaces.Instruction decfunc) (BLOCK (ALT FUNC ID PARIZQ listParams PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listParams.l, $type.t, $block.blk)}) (ALT FUNC ID PARIZQ listParams PARDER LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, $listaParams.l, environment.NULL, $block.blk)}) (ALT FUNC ID PARIZQ PARDER SUB MAYOR type LLAVEIZQ block LLAVEDER {$decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, $type.t, $block.blk)}) (ALT FUNC ID PARIZQ PARDER LLAVEIZQ (? (BLOCK (ALT block))) LLAVEDER {
    if($block.blk!=nil){ 
         $decfunc = instructions.NewToDeclareFunction($ID.line, $ID.pos, $ID.text, nil, environment.NULL, $block.blk)
    }
}))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}) (ALT emptvecstmt {$e = $emptvecstmt.emptyvec}) (ALT countvecstmt {$e = $countvecstmt.count}) (ALT accessvecstmt {$e = $accessvecstmt.accessvec}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr (? (BLOCK (ALT PTCOMA))) {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER}))) (RULE listParams (returns []interface{} l) (BLOCK (ALT (= list listParams) COMA expr {
                                var arr []interface{}
                                arr = append($list.l, $expr.e)
                                $l = arr
                            }) (ALT expr {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })))))
2023-09-01 22:02:19:691 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR GrammarLexer OPTIONS (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) RULES)
2023-09-01 22:02:19:713 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} op= NOT<tokenIndex=1245>   left=expr<tokenIndex=1249,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) } 
        | op = SUB<tokenIndex=1259>  left=expr<tokenIndex=1263,p=11> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)} 
        | PARIZQ<tokenIndex=1269> expr<tokenIndex=1271> PARDER<tokenIndex=1273> { $e = $expr.e } 
        | NUMBER<tokenIndex=1279>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=1285>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRUE<tokenIndex=1291> { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) } 
        | FALSE<tokenIndex=1297> { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) } 
        | NIL<tokenIndex=1303> { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) } 
        | accessstmt<tokenIndex=1309> {$e = $accessstmt.access} 
        | emptvecstmt<tokenIndex=1315> {$e = $emptvecstmt.emptyvec} 
        | countvecstmt<tokenIndex=1321> {$e = $countvecstmt.count} 
        | accessvecstmt<tokenIndex=1327> {$e = $accessvecstmt.accessvec} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 19)}?<p=19> op=(MUL<tokenIndex=1115>|DIV<tokenIndex=1117>) right=expr<tokenIndex=1122,p=20> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 18)}?<p=18> op=(ADD<tokenIndex=1135>|SUB<tokenIndex=1137>|PERCENT<tokenIndex=1139>) right=expr<tokenIndex=1144,p=19> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 17)}?<p=17> op=(MAY_IG<tokenIndex=1157>|MAYOR<tokenIndex=1159>) right=expr<tokenIndex=1164,p=18> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 16)}?<p=16> op=(MEN_IG<tokenIndex=1177>|MENOR<tokenIndex=1179>) right=expr<tokenIndex=1184,p=17> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> op=(IG_IG<tokenIndex=1197>|DIF<tokenIndex=1199>) right=expr<tokenIndex=1204,p=16> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=AND<tokenIndex=1216> right=expr<tokenIndex=1220,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=OR<tokenIndex=1232> right=expr<tokenIndex=1236,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-09-01 22:02:19:735 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (= op (NOT (ELEMENT_OPTIONS (= tokenIndex 1245)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 1249) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op (SUB (ELEMENT_OPTIONS (= tokenIndex 1259)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 1263) (= p 11)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 1269))) (expr (ELEMENT_OPTIONS (= tokenIndex 1271))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 1273))) { $e = $expr.e }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 1279))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 1285))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 1291))) { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 1297))) { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 1303))) { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT (accessstmt (ELEMENT_OPTIONS (= tokenIndex 1309))) {$e = $accessstmt.access}) (ALT (emptvecstmt (ELEMENT_OPTIONS (= tokenIndex 1315))) {$e = $emptvecstmt.emptyvec}) (ALT (countvecstmt (ELEMENT_OPTIONS (= tokenIndex 1321))) {$e = $countvecstmt.count}) (ALT (accessvecstmt (ELEMENT_OPTIONS (= tokenIndex 1327))) {$e = $accessvecstmt.accessvec})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 19)}? (ELEMENT_OPTIONS (= p 19))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 1115))) (DIV (ELEMENT_OPTIONS (= tokenIndex 1117))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1122) (= p 20)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 18)}? (ELEMENT_OPTIONS (= p 18))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 1135))) (SUB (ELEMENT_OPTIONS (= tokenIndex 1137))) (PERCENT (ELEMENT_OPTIONS (= tokenIndex 1139))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1144) (= p 19)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 17)}? (ELEMENT_OPTIONS (= p 17))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 1157))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 1159))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1164) (= p 18)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 16)}? (ELEMENT_OPTIONS (= p 16))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 1177))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 1179))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1184) (= p 17)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 1197))) (DIF (ELEMENT_OPTIONS (= tokenIndex 1199))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1204) (= p 16)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 1216)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1220) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 1232)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 1236) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-09-01 22:02:19:738 left-recursion LogManager.java:25 listParams returns [[]interface{} l]
    :   ( {} expr<tokenIndex=1439> {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        } 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 2)}?<p=2> COMA<tokenIndex=1431> expr<tokenIndex=1433> {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }
        )*
    ;
2023-09-01 22:02:19:740 grammar LogManager.java:25 added: (RULE listParams (returns []interface{} l) (BLOCK (ALT (BLOCK (ALT {} (expr (ELEMENT_OPTIONS (= tokenIndex 1439))) {
            $l = []interface{}{}
            $l = append($l, $expr.e)
        })) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 2)}? (ELEMENT_OPTIONS (= p 2))) (COMA (ELEMENT_OPTIONS (= tokenIndex 1431))) (expr (ELEMENT_OPTIONS (= tokenIndex 1433))) {
                                          var arr []interface{}
                                          arr = append($list.l, $expr.e)
                                          $l = arr
                                      }))))))
2023-09-01 22:02:19:753 grammar LogManager.java:25 import STRINGS=1
2023-09-01 22:02:19:753 grammar LogManager.java:25 import INTS=2
2023-09-01 22:02:19:753 grammar LogManager.java:25 import FLOATS=3
2023-09-01 22:02:19:753 grammar LogManager.java:25 import BOOLS=4
2023-09-01 22:02:19:753 grammar LogManager.java:25 import CHARACTERS=5
2023-09-01 22:02:19:753 grammar LogManager.java:25 import VAR=6
2023-09-01 22:02:19:753 grammar LogManager.java:25 import NIL=7
2023-09-01 22:02:19:753 grammar LogManager.java:25 import TRUE=8
2023-09-01 22:02:19:753 grammar LogManager.java:25 import FALSE=9
2023-09-01 22:02:19:754 grammar LogManager.java:25 import PRINT=10
2023-09-01 22:02:19:754 grammar LogManager.java:25 import IF=11
2023-09-01 22:02:19:754 grammar LogManager.java:25 import ELSE=12
2023-09-01 22:02:19:754 grammar LogManager.java:25 import WHILE=13
2023-09-01 22:02:19:754 grammar LogManager.java:25 import LET=14
2023-09-01 22:02:19:754 grammar LogManager.java:25 import FOR=15
2023-09-01 22:02:19:754 grammar LogManager.java:25 import IN=16
2023-09-01 22:02:19:754 grammar LogManager.java:25 import SWITCH=17
2023-09-01 22:02:19:754 grammar LogManager.java:25 import CASE=18
2023-09-01 22:02:19:754 grammar LogManager.java:25 import DEFAULT=19
2023-09-01 22:02:19:754 grammar LogManager.java:25 import GUARD=20
2023-09-01 22:02:19:754 grammar LogManager.java:25 import CONTINUE=21
2023-09-01 22:02:19:754 grammar LogManager.java:25 import RETURN=22
2023-09-01 22:02:19:755 grammar LogManager.java:25 import BREAK=23
2023-09-01 22:02:19:755 grammar LogManager.java:25 import APPEND=24
2023-09-01 22:02:19:755 grammar LogManager.java:25 import REMOVELAST=25
2023-09-01 22:02:19:755 grammar LogManager.java:25 import REMOVE=26
2023-09-01 22:02:19:755 grammar LogManager.java:25 import AT=27
2023-09-01 22:02:19:755 grammar LogManager.java:25 import ISEMPTY=28
2023-09-01 22:02:19:755 grammar LogManager.java:25 import COUNT=29
2023-09-01 22:02:19:755 grammar LogManager.java:25 import FUNC=30
2023-09-01 22:02:19:755 grammar LogManager.java:25 import INOUT=31
2023-09-01 22:02:19:755 grammar LogManager.java:25 import NUMBER=32
2023-09-01 22:02:19:755 grammar LogManager.java:25 import STRING=33
2023-09-01 22:02:19:755 grammar LogManager.java:25 import ID=34
2023-09-01 22:02:19:755 grammar LogManager.java:25 import DIF=35
2023-09-01 22:02:19:755 grammar LogManager.java:25 import IG_IG=36
2023-09-01 22:02:19:755 grammar LogManager.java:25 import NOT=37
2023-09-01 22:02:19:755 grammar LogManager.java:25 import OR=38
2023-09-01 22:02:19:755 grammar LogManager.java:25 import AND=39
2023-09-01 22:02:19:756 grammar LogManager.java:25 import IG=40
2023-09-01 22:02:19:756 grammar LogManager.java:25 import IG_ADD=41
2023-09-01 22:02:19:756 grammar LogManager.java:25 import IG_SUB=42
2023-09-01 22:02:19:756 grammar LogManager.java:25 import MAY_IG=43
2023-09-01 22:02:19:756 grammar LogManager.java:25 import MEN_IG=44
2023-09-01 22:02:19:757 grammar LogManager.java:25 import MAYOR=45
2023-09-01 22:02:19:757 grammar LogManager.java:25 import MENOR=46
2023-09-01 22:02:19:757 grammar LogManager.java:25 import MUL=47
2023-09-01 22:02:19:757 grammar LogManager.java:25 import DIV=48
2023-09-01 22:02:19:757 grammar LogManager.java:25 import ADD=49
2023-09-01 22:02:19:757 grammar LogManager.java:25 import SUB=50
2023-09-01 22:02:19:757 grammar LogManager.java:25 import PERCENT=51
2023-09-01 22:02:19:757 grammar LogManager.java:25 import PARIZQ=52
2023-09-01 22:02:19:757 grammar LogManager.java:25 import PARDER=53
2023-09-01 22:02:19:757 grammar LogManager.java:25 import LLAVEIZQ=54
2023-09-01 22:02:19:757 grammar LogManager.java:25 import LLAVEDER=55
2023-09-01 22:02:19:757 grammar LogManager.java:25 import DOUBLEPTS=56
2023-09-01 22:02:19:757 grammar LogManager.java:25 import QUESTION=57
2023-09-01 22:02:19:757 grammar LogManager.java:25 import POINT=58
2023-09-01 22:02:19:757 grammar LogManager.java:25 import COMA=59
2023-09-01 22:02:19:757 grammar LogManager.java:25 import PTCOMA=60
2023-09-01 22:02:19:757 grammar LogManager.java:25 import CORCHETEIZQ=61
2023-09-01 22:02:19:757 grammar LogManager.java:25 import CORCHETEDER=62
2023-09-01 22:02:19:757 grammar LogManager.java:25 import WHITESPACE=63
2023-09-01 22:02:19:757 grammar LogManager.java:25 import COMMENT=64
2023-09-01 22:02:19:757 grammar LogManager.java:25 import LINE_COMMENT=65
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'String'=1
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'Int'=2
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'Float'=3
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'Bool'=4
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'Character'=5
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'var'=6
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'nil'=7
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'true'=8
2023-09-01 22:02:19:757 grammar LogManager.java:25 import 'false'=9
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'print'=10
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'if'=11
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'else'=12
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'while'=13
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'let'=14
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'for'=15
2023-09-01 22:02:19:759 grammar LogManager.java:25 import 'in'=16
2023-09-01 22:02:19:760 grammar LogManager.java:25 import 'switch'=17
2023-09-01 22:02:19:760 grammar LogManager.java:25 import 'case'=18
2023-09-01 22:02:19:760 grammar LogManager.java:25 import 'default'=19
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'guard'=20
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'continue'=21
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'return'=22
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'break'=23
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'append'=24
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'removeLast'=25
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'remove'=26
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'at'=27
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'IsEmpty'=28
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'count'=29
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'func'=30
2023-09-01 22:02:19:761 grammar LogManager.java:25 import 'inout'=31
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '!='=35
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '=='=36
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '!'=37
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '||'=38
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '&&'=39
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '='=40
2023-09-01 22:02:19:761 grammar LogManager.java:25 import '+='=41
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '-='=42
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '>='=43
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '<='=44
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '>'=45
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '<'=46
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '*'=47
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '/'=48
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '+'=49
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '-'=50
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '%'=51
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '('=52
2023-09-01 22:02:19:762 grammar LogManager.java:25 import ')'=53
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '{'=54
2023-09-01 22:02:19:762 grammar LogManager.java:25 import '}'=55
2023-09-01 22:02:19:763 grammar LogManager.java:25 import ':'=56
2023-09-01 22:02:19:763 grammar LogManager.java:25 import '?'=57
2023-09-01 22:02:19:763 grammar LogManager.java:25 import '.'=58
2023-09-01 22:02:19:763 grammar LogManager.java:25 import ','=59
2023-09-01 22:02:19:763 grammar LogManager.java:25 import ';'=60
2023-09-01 22:02:19:763 grammar LogManager.java:25 import '['=61
2023-09-01 22:02:19:763 grammar LogManager.java:25 import ']'=62
2023-09-01 22:02:19:765 grammar LogManager.java:25 tokens={STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, GUARD=20, CONTINUE=21, RETURN=22, BREAK=23, APPEND=24, REMOVELAST=25, REMOVE=26, AT=27, ISEMPTY=28, COUNT=29, FUNC=30, INOUT=31, NUMBER=32, STRING=33, ID=34, DIF=35, IG_IG=36, NOT=37, OR=38, AND=39, IG=40, IG_ADD=41, IG_SUB=42, MAY_IG=43, MEN_IG=44, MAYOR=45, MENOR=46, MUL=47, DIV=48, ADD=49, SUB=50, PERCENT=51, PARIZQ=52, PARDER=53, LLAVEIZQ=54, LLAVEDER=55, DOUBLEPTS=56, QUESTION=57, POINT=58, COMA=59, PTCOMA=60, CORCHETEIZQ=61, CORCHETEDER=62, WHITESPACE=63, COMMENT=64, LINE_COMMENT=65, 'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'guard'=20, 'continue'=21, 'return'=22, 'break'=23, 'append'=24, 'removeLast'=25, 'remove'=26, 'at'=27, 'IsEmpty'=28, 'count'=29, 'func'=30, 'inout'=31, '!='=35, '=='=36, '!'=37, '||'=38, '&&'=39, '='=40, '+='=41, '-='=42, '>='=43, '<='=44, '>'=45, '<'=46, '*'=47, '/'=48, '+'=49, '-'=50, '%'=51, '('=52, ')'=53, '{'=54, '}'=55, ':'=56, '?'=57, '.'=58, ','=59, ';'=60, '['=61, ']'=62}
2023-09-01 22:02:19:766 semantics LogManager.java:25 tokens={EOF=-1, STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, SWITCH=17, CASE=18, DEFAULT=19, GUARD=20, CONTINUE=21, RETURN=22, BREAK=23, APPEND=24, REMOVELAST=25, REMOVE=26, AT=27, ISEMPTY=28, COUNT=29, FUNC=30, INOUT=31, NUMBER=32, STRING=33, ID=34, DIF=35, IG_IG=36, NOT=37, OR=38, AND=39, IG=40, IG_ADD=41, IG_SUB=42, MAY_IG=43, MEN_IG=44, MAYOR=45, MENOR=46, MUL=47, DIV=48, ADD=49, SUB=50, PERCENT=51, PARIZQ=52, PARDER=53, LLAVEIZQ=54, LLAVEDER=55, DOUBLEPTS=56, QUESTION=57, POINT=58, COMA=59, PTCOMA=60, CORCHETEIZQ=61, CORCHETEDER=62, WHITESPACE=63, COMMENT=64, LINE_COMMENT=65}
2023-09-01 22:02:19:766 semantics LogManager.java:25 strings={'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, 'switch'=17, 'case'=18, 'default'=19, 'guard'=20, 'continue'=21, 'return'=22, 'break'=23, 'append'=24, 'removeLast'=25, 'remove'=26, 'at'=27, 'IsEmpty'=28, 'count'=29, 'func'=30, 'inout'=31, '!='=35, '=='=36, '!'=37, '||'=38, '&&'=39, '='=40, '+='=41, '-='=42, '>='=43, '<='=44, '>'=45, '<'=46, '*'=47, '/'=48, '+'=49, '-'=50, '%'=51, '('=52, ')'=53, '{'=54, '}'=55, ':'=56, '?'=57, '.'=58, ','=59, ';'=60, '['=61, ']'=62}
