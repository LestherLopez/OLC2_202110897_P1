2023-08-23 02:21:29:859 grammar LogManager.java:25 before: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (BLOCK (ALT '\\') (ALT '@') (ALT '[') (ALT ']') (ALT '.') (ALT '#') (ALT '+') (ALT '-') (ALT '!') (ALT ':') (ALT ' ')))))))
2023-08-23 02:21:29:895 grammar LogManager.java:25 after: (LEXER_GRAMMAR Lex (RULES (RULE STRINGS (BLOCK (ALT 'String'))) (RULE INTS (BLOCK (ALT 'Int'))) (RULE FLOATS (BLOCK (ALT 'Float'))) (RULE BOOLS (BLOCK (ALT 'Bool'))) (RULE CHARACTERS (BLOCK (ALT 'Character'))) (RULE VAR (BLOCK (ALT 'var'))) (RULE NIL (BLOCK (ALT 'nil'))) (RULE TRUE (BLOCK (ALT 'true'))) (RULE FALSE (BLOCK (ALT 'false'))) (RULE PRINT (BLOCK (ALT 'print'))) (RULE IF (BLOCK (ALT 'if'))) (RULE ELSE (BLOCK (ALT 'else'))) (RULE WHILE (BLOCK (ALT 'while'))) (RULE LET (BLOCK (ALT 'let'))) (RULE FOR (BLOCK (ALT 'for'))) (RULE IN (BLOCK (ALT 'in'))) (RULE NUMBER (BLOCK (ALT (+ (BLOCK (ALT [0-9]))) (? (BLOCK (ALT '.' (+ (BLOCK (ALT [0-9]))))))))) (RULE STRING (BLOCK (ALT '"' (* (BLOCK (ALT (~ (SET ["]))))) '"'))) (RULE ID (BLOCK (ALT (BLOCK (ALT [a-zA-Z])) (* (BLOCK (ALT [a-zA-Z0-9_])))))) (RULE DIF (BLOCK (ALT '!='))) (RULE IG_IG (BLOCK (ALT '=='))) (RULE NOT (BLOCK (ALT '!'))) (RULE OR (BLOCK (ALT '||'))) (RULE AND (BLOCK (ALT '&&'))) (RULE IG (BLOCK (ALT '='))) (RULE IG_ADD (BLOCK (ALT '+='))) (RULE IG_SUB (BLOCK (ALT '-='))) (RULE MAY_IG (BLOCK (ALT '>='))) (RULE MEN_IG (BLOCK (ALT '<='))) (RULE MAYOR (BLOCK (ALT '>'))) (RULE MENOR (BLOCK (ALT '<'))) (RULE MUL (BLOCK (ALT '*'))) (RULE DIV (BLOCK (ALT '/'))) (RULE ADD (BLOCK (ALT '+'))) (RULE SUB (BLOCK (ALT '-'))) (RULE PERCENT (BLOCK (ALT '%'))) (RULE PARIZQ (BLOCK (ALT '('))) (RULE PARDER (BLOCK (ALT ')'))) (RULE LLAVEIZQ (BLOCK (ALT '{'))) (RULE LLAVEDER (BLOCK (ALT '}'))) (RULE DOUBLEPTS (BLOCK (ALT ':'))) (RULE QUESTION (BLOCK (ALT '?'))) (RULE WHITESPACE (BLOCK (LEXER_ALT_ACTION (ALT (+ (BLOCK (ALT [ \\\r\n\t])))) skip))) (RULE COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '/*' (* (BLOCK (ALT .))) '*/') skip))) (RULE LINE_COMMENT (BLOCK (LEXER_ALT_ACTION (ALT '//' (* (BLOCK (ALT (~ (SET [\r\n])))))) skip))) (RULE ESC_SEQ (RULEMODIFIERS fragment) (BLOCK (ALT '\\' (SET '\\' '@' '[' ']' '.' '#' '+' '-' '!' ':' ' '))))))
2023-08-23 02:21:30:810 grammar LogManager.java:25 before: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $expr.e)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE ifstmt (returns interfaces.Instruction ift) (BLOCK (ALT IF PARIZQ expr PARDER LLAVEIZQ instruction LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER ELSE LLAVEIZQ block LLAVEDER) (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER ELSE ifstmt))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr {$assign = instructions.NewAssignation($IG.line, $IG.pos,  $ID.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (BLOCK (ALT MUL) (ALT DIV))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT ADD) (ALT SUB) (ALT PERCENT))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MAY_IG) (ALT MAYOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT MEN_IG) (ALT MENOR))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (BLOCK (ALT IG_IG) (ALT DIF))) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER})))))
2023-08-23 02:21:30:828 grammar LogManager.java:25 after: (COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $expr.e)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE ifstmt (returns interfaces.Instruction ift) (BLOCK (ALT IF PARIZQ expr PARDER LLAVEIZQ instruction LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER ELSE LLAVEIZQ block LLAVEDER) (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER ELSE ifstmt))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr {$assign = instructions.NewAssignation($IG.line, $IG.pos,  $ID.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER})))))
2023-08-23 02:21:30:834 grammar LogManager.java:25 after extract implicit lexer =(COMBINED_GRAMMAR Grammar (OPTIONS (= tokenVocab Lex)) (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) (RULES (RULE s (returns []interface{} code) (BLOCK (ALT block EOF {$code = $block.blk}))) (RULE block (returns []interface{} blk) (@ init {
$blk = []interface{}{}
    var listInt []IInstructionContext
  }) (BLOCK (ALT (+ (BLOCK (ALT (+= ins instruction)))) {
        listInt = localctx.(*BlockContext).GetIns()
        for _, e := range listInt {
            $blk = append($blk, e.GetInst())
        }
    }))) (RULE instruction (returns interfaces.Instruction inst) (BLOCK (ALT printstmt { $inst = $printstmt.prnt}) (ALT declarestmt {$inst = $declarestmt.dec}) (ALT constantstmt {$inst = $constantstmt.const}) (ALT ifstmt { $inst = $ifstmt.ift }) (ALT assignationstmt {$inst = $assignationstmt.assign}) (ALT increaseanddecreasestmt {$inst = $increaseanddecreasestmt.increasedecrease}))) (RULE printstmt (returns interfaces.Instruction prnt) (BLOCK (ALT PRINT PARIZQ expr PARDER { $prnt = instructions.NewPrint($PRINT.line, $PRINT.pos, $expr.e)}))) (RULE declarestmt (returns interfaces.Instruction dec) (BLOCK (ALT VAR ID DOUBLEPTS type IG expr {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, $expr.e, false)}) (ALT VAR ID IG expr {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, environment.NULL, $expr.e, false)}) (ALT VAR ID DOUBLEPTS type QUESTION {$dec = instructions.NewTodeclare($VAR.line, $VAR.pos, $ID.text, $type.t, nil, false)}))) (RULE constantstmt (returns interfaces.Instruction const) (BLOCK (ALT LET ID DOUBLEPTS type IG expr {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, $type.t, $expr.e, true)}) (ALT LET ID IG expr {$const = instructions.NewTodeclare($LET.line, $LET.pos, $ID.text, environment.NULL, $expr.e, true)}))) (RULE ifstmt (returns interfaces.Instruction ift) (BLOCK (ALT IF PARIZQ expr PARDER LLAVEIZQ instruction LLAVEDER { $ift = instructions.NewIf($IF.line, $IF.pos, $expr.e, $block.blk, nil) }) (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER ELSE LLAVEIZQ block LLAVEDER) (ALT IF PARIZQ expr PARDER LLAVEIZQ block LLAVEDER ELSE ifstmt))) (RULE assignationstmt (returns interfaces.Instruction assign) (BLOCK (ALT ID IG expr {$assign = instructions.NewAssignation($IG.line, $IG.pos,  $ID.text, $expr.e)}))) (RULE whilestmt (returns interfaces.Instruction while) (BLOCK (ALT WHILE expr LLAVEIZQ block LLAVEDER {$while = instructions.NewWhile($WHILE.line, $WHILE.pos,  $expr.e, $block.blk)}))) (RULE forstmt (returns interfaces.Instruction for) (BLOCK (ALT FOR ID IN expr LLAVEIZQ block LLAVEDER))) (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (= left expr) (= op (SET MUL DIV)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET ADD SUB PERCENT)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MAY_IG MAYOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET MEN_IG MENOR)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op (SET IG_IG DIF)) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op AND) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= left expr) (= op OR) (= right expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT (= op NOT) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op SUB) (= left expr) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT PARIZQ expr PARDER { $e = $expr.e }) (ALT NUMBER {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT STRING {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT TRUE { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT FALSE { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT NIL { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT accessstmt {$e = $accessstmt.access}))) (RULE accessstmt (returns interfaces.Expression access) (BLOCK (ALT (= op ID) {$access = expressions.NewAccess($op.line, $op.pos, $op.text)}))) (RULE increaseanddecreasestmt (returns interfaces.Instruction increasedecrease) (BLOCK (ALT ID IG_ADD expr {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_ADD.text, $expr.e)}) (ALT ID IG_SUB expr {$increasedecrease = instructions.NewIncreaseDecrease($ID.line, $ID.pos, $ID.text, $IG_SUB.text, $expr.e)}))) (RULE type (returns environment.TipoExpresion t) (BLOCK (ALT STRINGS {$t = environment.STRING}) (ALT INTS {$t = environment.INTEGER}) (ALT FLOATS {$t = environment.FLOAT}) (ALT BOOLS {$t = environment.BOOLEAN }) (ALT CHARACTERS {$t = environment.CHARACTER})))))
2023-08-23 02:21:30:834 grammar LogManager.java:25 lexer =(LEXER_GRAMMAR GrammarLexer OPTIONS (@ header {
    import "Server/Interfaces"
    import "Server/Environment"
    import "Server/Expression"
    import "Server/Instruction"
    import "strings"
}) RULES)
2023-08-23 02:21:30:887 left-recursion LogManager.java:25 expr returns [interfaces.Expression e]
    :   ( {} op= NOT<tokenIndex=503>   left=expr<tokenIndex=507,p=9> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) } 
        | op = SUB<tokenIndex=517>  left=expr<tokenIndex=521,p=8> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)} 
        | PARIZQ<tokenIndex=527> expr<tokenIndex=529> PARDER<tokenIndex=531> { $e = $expr.e } 
        | NUMBER<tokenIndex=537>                             
    {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    } 
        | STRING<tokenIndex=543>
    {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    } 
        | TRUE<tokenIndex=549> { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) } 
        | FALSE<tokenIndex=555> { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) } 
        | NIL<tokenIndex=561> { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) } 
        | accessstmt<tokenIndex=567> {$e = $accessstmt.access} 
        )
        (
          {p.Precpred(p.GetParserRuleContext(), 16)}?<p=16> op=(MUL<tokenIndex=373>|DIV<tokenIndex=375>) right=expr<tokenIndex=380,p=17> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 15)}?<p=15> op=(ADD<tokenIndex=393>|SUB<tokenIndex=395>|PERCENT<tokenIndex=397>) right=expr<tokenIndex=402,p=16> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 14)}?<p=14> op=(MAY_IG<tokenIndex=415>|MAYOR<tokenIndex=417>) right=expr<tokenIndex=422,p=15> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 13)}?<p=13> op=(MEN_IG<tokenIndex=435>|MENOR<tokenIndex=437>) right=expr<tokenIndex=442,p=14> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 12)}?<p=12> op=(IG_IG<tokenIndex=455>|DIF<tokenIndex=457>) right=expr<tokenIndex=462,p=13> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 11)}?<p=11> op=AND<tokenIndex=474> right=expr<tokenIndex=478,p=12> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
                  | {p.Precpred(p.GetParserRuleContext(), 10)}?<p=10> op=OR<tokenIndex=490> right=expr<tokenIndex=494,p=11> { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }
        )*
    ;
2023-08-23 02:21:30:938 grammar LogManager.java:25 added: (RULE expr (returns interfaces.Expression e) (BLOCK (ALT (BLOCK (ALT {} (= op (NOT (ELEMENT_OPTIONS (= tokenIndex 503)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 507) (= p 9)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $left.e) }) (ALT (= op (SUB (ELEMENT_OPTIONS (= tokenIndex 517)))) (= left (expr (ELEMENT_OPTIONS (= tokenIndex 521) (= p 8)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e,  $op.text, nil)}) (ALT (PARIZQ (ELEMENT_OPTIONS (= tokenIndex 527))) (expr (ELEMENT_OPTIONS (= tokenIndex 529))) (PARDER (ELEMENT_OPTIONS (= tokenIndex 531))) { $e = $expr.e }) (ALT (NUMBER (ELEMENT_OPTIONS (= tokenIndex 537))) {
        if (strings.Contains($NUMBER.text,".")){
            num,err := strconv.ParseFloat($NUMBER.text, 64);
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.FLOAT)
        }else{
            num,err := strconv.Atoi($NUMBER.text)
            if err!= nil{
                fmt.Println(err)
            }
            $e = expressions.NewPrimitive($NUMBER.line,$NUMBER.pos,num,environment.INTEGER)
        }
    }) (ALT (STRING (ELEMENT_OPTIONS (= tokenIndex 543))) {
        str := $STRING.text
        $e = expressions.NewPrimitive($STRING.line, $STRING.pos, str[1:len(str)-1],environment.STRING)
    }) (ALT (TRUE (ELEMENT_OPTIONS (= tokenIndex 549))) { $e = expressions.NewPrimitive($TRUE.line, $TRUE.pos, true, environment.BOOLEAN) }) (ALT (FALSE (ELEMENT_OPTIONS (= tokenIndex 555))) { $e = expressions.NewPrimitive($FALSE.line, $FALSE.pos, false, environment.BOOLEAN) }) (ALT (NIL (ELEMENT_OPTIONS (= tokenIndex 561))) { $e = expressions.NewPrimitive($NIL.line, $NIL.pos, nil, environment.NULL) }) (ALT (accessstmt (ELEMENT_OPTIONS (= tokenIndex 567))) {$e = $accessstmt.access})) (* (BLOCK (ALT ({p.Precpred(p.GetParserRuleContext(), 16)}? (ELEMENT_OPTIONS (= p 16))) (= op (SET (MUL (ELEMENT_OPTIONS (= tokenIndex 373))) (DIV (ELEMENT_OPTIONS (= tokenIndex 375))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 380) (= p 17)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 15)}? (ELEMENT_OPTIONS (= p 15))) (= op (SET (ADD (ELEMENT_OPTIONS (= tokenIndex 393))) (SUB (ELEMENT_OPTIONS (= tokenIndex 395))) (PERCENT (ELEMENT_OPTIONS (= tokenIndex 397))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 402) (= p 16)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 14)}? (ELEMENT_OPTIONS (= p 14))) (= op (SET (MAY_IG (ELEMENT_OPTIONS (= tokenIndex 415))) (MAYOR (ELEMENT_OPTIONS (= tokenIndex 417))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 422) (= p 15)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 13)}? (ELEMENT_OPTIONS (= p 13))) (= op (SET (MEN_IG (ELEMENT_OPTIONS (= tokenIndex 435))) (MENOR (ELEMENT_OPTIONS (= tokenIndex 437))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 442) (= p 14)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 12)}? (ELEMENT_OPTIONS (= p 12))) (= op (SET (IG_IG (ELEMENT_OPTIONS (= tokenIndex 455))) (DIF (ELEMENT_OPTIONS (= tokenIndex 457))))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 462) (= p 13)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 11)}? (ELEMENT_OPTIONS (= p 11))) (= op (AND (ELEMENT_OPTIONS (= tokenIndex 474)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 478) (= p 12)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }) (ALT ({p.Precpred(p.GetParserRuleContext(), 10)}? (ELEMENT_OPTIONS (= p 10))) (= op (OR (ELEMENT_OPTIONS (= tokenIndex 490)))) (= right (expr (ELEMENT_OPTIONS (= tokenIndex 494) (= p 11)))) { $e = expressions.NewOperation($left.start.GetLine(), $left.start.GetColumn(), $left.e, $op.text, $right.e) }))))))
2023-08-23 02:21:30:970 grammar LogManager.java:25 import STRINGS=1
2023-08-23 02:21:30:970 grammar LogManager.java:25 import INTS=2
2023-08-23 02:21:30:970 grammar LogManager.java:25 import FLOATS=3
2023-08-23 02:21:30:971 grammar LogManager.java:25 import BOOLS=4
2023-08-23 02:21:30:971 grammar LogManager.java:25 import CHARACTERS=5
2023-08-23 02:21:30:971 grammar LogManager.java:25 import VAR=6
2023-08-23 02:21:30:972 grammar LogManager.java:25 import NIL=7
2023-08-23 02:21:30:972 grammar LogManager.java:25 import TRUE=8
2023-08-23 02:21:30:972 grammar LogManager.java:25 import FALSE=9
2023-08-23 02:21:30:973 grammar LogManager.java:25 import PRINT=10
2023-08-23 02:21:30:973 grammar LogManager.java:25 import IF=11
2023-08-23 02:21:30:974 grammar LogManager.java:25 import ELSE=12
2023-08-23 02:21:30:974 grammar LogManager.java:25 import WHILE=13
2023-08-23 02:21:30:974 grammar LogManager.java:25 import LET=14
2023-08-23 02:21:30:974 grammar LogManager.java:25 import FOR=15
2023-08-23 02:21:30:974 grammar LogManager.java:25 import IN=16
2023-08-23 02:21:30:975 grammar LogManager.java:25 import NUMBER=17
2023-08-23 02:21:30:975 grammar LogManager.java:25 import STRING=18
2023-08-23 02:21:30:975 grammar LogManager.java:25 import ID=19
2023-08-23 02:21:30:976 grammar LogManager.java:25 import DIF=20
2023-08-23 02:21:30:977 grammar LogManager.java:25 import IG_IG=21
2023-08-23 02:21:30:977 grammar LogManager.java:25 import NOT=22
2023-08-23 02:21:30:978 grammar LogManager.java:25 import OR=23
2023-08-23 02:21:30:979 grammar LogManager.java:25 import AND=24
2023-08-23 02:21:30:980 grammar LogManager.java:25 import IG=25
2023-08-23 02:21:30:980 grammar LogManager.java:25 import IG_ADD=26
2023-08-23 02:21:30:981 grammar LogManager.java:25 import IG_SUB=27
2023-08-23 02:21:30:981 grammar LogManager.java:25 import MAY_IG=28
2023-08-23 02:21:30:981 grammar LogManager.java:25 import MEN_IG=29
2023-08-23 02:21:30:981 grammar LogManager.java:25 import MAYOR=30
2023-08-23 02:21:30:981 grammar LogManager.java:25 import MENOR=31
2023-08-23 02:21:30:982 grammar LogManager.java:25 import MUL=32
2023-08-23 02:21:30:982 grammar LogManager.java:25 import DIV=33
2023-08-23 02:21:30:983 grammar LogManager.java:25 import ADD=34
2023-08-23 02:21:30:983 grammar LogManager.java:25 import SUB=35
2023-08-23 02:21:30:984 grammar LogManager.java:25 import PERCENT=36
2023-08-23 02:21:30:984 grammar LogManager.java:25 import PARIZQ=37
2023-08-23 02:21:30:984 grammar LogManager.java:25 import PARDER=38
2023-08-23 02:21:30:985 grammar LogManager.java:25 import LLAVEIZQ=39
2023-08-23 02:21:30:985 grammar LogManager.java:25 import LLAVEDER=40
2023-08-23 02:21:30:985 grammar LogManager.java:25 import DOUBLEPTS=41
2023-08-23 02:21:30:986 grammar LogManager.java:25 import QUESTION=42
2023-08-23 02:21:30:986 grammar LogManager.java:25 import WHITESPACE=43
2023-08-23 02:21:30:986 grammar LogManager.java:25 import COMMENT=44
2023-08-23 02:21:30:986 grammar LogManager.java:25 import LINE_COMMENT=45
2023-08-23 02:21:30:986 grammar LogManager.java:25 import 'String'=1
2023-08-23 02:21:30:986 grammar LogManager.java:25 import 'Int'=2
2023-08-23 02:21:30:986 grammar LogManager.java:25 import 'Float'=3
2023-08-23 02:21:30:986 grammar LogManager.java:25 import 'Bool'=4
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'Character'=5
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'var'=6
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'nil'=7
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'true'=8
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'false'=9
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'print'=10
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'if'=11
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'else'=12
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'while'=13
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'let'=14
2023-08-23 02:21:30:987 grammar LogManager.java:25 import 'for'=15
2023-08-23 02:21:30:988 grammar LogManager.java:25 import 'in'=16
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '!='=20
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '=='=21
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '!'=22
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '||'=23
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '&&'=24
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '='=25
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '+='=26
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '-='=27
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '>='=28
2023-08-23 02:21:30:988 grammar LogManager.java:25 import '<='=29
2023-08-23 02:21:30:989 grammar LogManager.java:25 import '>'=30
2023-08-23 02:21:30:989 grammar LogManager.java:25 import '<'=31
2023-08-23 02:21:30:989 grammar LogManager.java:25 import '*'=32
2023-08-23 02:21:30:990 grammar LogManager.java:25 import '/'=33
2023-08-23 02:21:30:990 grammar LogManager.java:25 import '+'=34
2023-08-23 02:21:30:990 grammar LogManager.java:25 import '-'=35
2023-08-23 02:21:30:991 grammar LogManager.java:25 import '%'=36
2023-08-23 02:21:30:991 grammar LogManager.java:25 import '('=37
2023-08-23 02:21:30:991 grammar LogManager.java:25 import ')'=38
2023-08-23 02:21:30:992 grammar LogManager.java:25 import '{'=39
2023-08-23 02:21:30:992 grammar LogManager.java:25 import '}'=40
2023-08-23 02:21:30:992 grammar LogManager.java:25 import ':'=41
2023-08-23 02:21:30:993 grammar LogManager.java:25 import '?'=42
2023-08-23 02:21:30:994 grammar LogManager.java:25 tokens={STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, NUMBER=17, STRING=18, ID=19, DIF=20, IG_IG=21, NOT=22, OR=23, AND=24, IG=25, IG_ADD=26, IG_SUB=27, MAY_IG=28, MEN_IG=29, MAYOR=30, MENOR=31, MUL=32, DIV=33, ADD=34, SUB=35, PERCENT=36, PARIZQ=37, PARDER=38, LLAVEIZQ=39, LLAVEDER=40, DOUBLEPTS=41, QUESTION=42, WHITESPACE=43, COMMENT=44, LINE_COMMENT=45, 'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, '!='=20, '=='=21, '!'=22, '||'=23, '&&'=24, '='=25, '+='=26, '-='=27, '>='=28, '<='=29, '>'=30, '<'=31, '*'=32, '/'=33, '+'=34, '-'=35, '%'=36, '('=37, ')'=38, '{'=39, '}'=40, ':'=41, '?'=42}
2023-08-23 02:21:30:996 semantics LogManager.java:25 tokens={EOF=-1, STRINGS=1, INTS=2, FLOATS=3, BOOLS=4, CHARACTERS=5, VAR=6, NIL=7, TRUE=8, FALSE=9, PRINT=10, IF=11, ELSE=12, WHILE=13, LET=14, FOR=15, IN=16, NUMBER=17, STRING=18, ID=19, DIF=20, IG_IG=21, NOT=22, OR=23, AND=24, IG=25, IG_ADD=26, IG_SUB=27, MAY_IG=28, MEN_IG=29, MAYOR=30, MENOR=31, MUL=32, DIV=33, ADD=34, SUB=35, PERCENT=36, PARIZQ=37, PARDER=38, LLAVEIZQ=39, LLAVEDER=40, DOUBLEPTS=41, QUESTION=42, WHITESPACE=43, COMMENT=44, LINE_COMMENT=45}
2023-08-23 02:21:30:996 semantics LogManager.java:25 strings={'String'=1, 'Int'=2, 'Float'=3, 'Bool'=4, 'Character'=5, 'var'=6, 'nil'=7, 'true'=8, 'false'=9, 'print'=10, 'if'=11, 'else'=12, 'while'=13, 'let'=14, 'for'=15, 'in'=16, '!='=20, '=='=21, '!'=22, '||'=23, '&&'=24, '='=25, '+='=26, '-='=27, '>='=28, '<='=29, '>'=30, '<'=31, '*'=32, '/'=33, '+'=34, '-'=35, '%'=36, '('=37, ')'=38, '{'=39, '}'=40, ':'=41, '?'=42}
